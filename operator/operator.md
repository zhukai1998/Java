在除法中分为除数和被除数，即：被除数 / 除数 = 商。
被除数 除以 除数   等于 商
除数   除   被除数 等于 商
如 6 / 3 = 2，可描述为 6 除以 3 = 2；或者是 3 除 6 = 2


- 当参与 / 运算的两个操作数都是整数时，表示整数除法，否则表示浮点除法
-- 需要注意的是，整数 / 0 会产生一个异常；浮点 / 0 会得到无穷大或 NaN 结果

- 为了可移植性，Java 虚拟机的最初规范规定所有的中间计算都必须进行截断。这种行为遭到了数值计算团队的反对。截断计算不仅可能导致溢出，而且由于阶段操作需要消耗时间，所以在计算速度山实际要比精确计算慢。为此 Java 程序设计语言承认最优性能与理想结果存在的冲突。在默认情况下虚拟机设计者允许对中间计算结果采用扩展的精度。但是对于 strictfp 关键字标记的方法或类必须使用严格的浮点计算

- 计算数值的平方根 Math.sqrt(x)
- 幂运算 Math.pow(x, a) pow 方法有两个 double 类型的参数，其返回结果也为 double

- floorMode 方法的目的是解决一个长期存在的有关整数取余的问题。如 n % 2，一般 n 是偶数，则表达式为 0；若 n 是奇数，则表达式为 1；若 n 是负数，则表达式为 -1.为什么呢？设计最早的计算机时，必须有人制定规则，明确整数除法和求余对负数操作数该如何处理。根据最优（欧几里得）原则：余数总要大于等于 0，但最早制订规则的人，提出一些看似合理但实际上很不方便的规则。
-- 例如：计算一个时钟时针的位置，这里要做一个时间调整，而且要归一化为一个 0 ～ 11 之间的数。这很简单：（position + adjustment） % 12 。不过，如果这个调整为负会怎么样？你会得到一个负数，所以要引入一个分支，或者使用（（position + adjustment）% 12 + 12）% 12.不管怎样，总之很麻烦，floorMod（position + adjustment， 12）总会得到一个 0 ～ 11 之间的数，不过若第二个参数为负数，也就是除负数，floorMod会得到负数结果

- 在 Math 类中，为了达到最快性能，所有的方法都是用计算机浮点单元中的历程，如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用 StrictMath 类

# 数值类型之间的转换
- byte ---> short ---> int ---> long 无信息丢失
- char ---> int 无信息丢失
- int ---> float 有信息丢失
- int ---> double 无信息丢失
- long ---> float  有信息丢失
- long ---> double 有信息丢失
- float ---> double  无信息丢失

- 当两个操作数进行二元操作时，需统一类型再进行计算
-- 一个是 double，另一个转为 double
-- 否则，一个是 float，另一个转为 float
-- 否则，一个是 long，另一个转为 long
-- 否则，都被转为 int

- 强制类型转换会丢失信息，想对浮点数做舍入运算，得到最接近的整数 Math.round 方法，返回 long 类型
-- 当强制类型转换时，超出目标类型的表示范围，则会被截断一个完全不同的值，如（byte）300 的实际值为 44

- 赋值中使用二元运算符，将运算符写在 = 的左边

- 自增运算符，前缀先加后运算，后缀先运算后加
-- 建议不要使用 自增运算

- && 逻辑与  只有两个表达式结果都为 true，则其结果为 true
- || 逻辑或  只要一个表达式结果为 true，则其结果为 true
- &&  和 || 都是按照短路的方式求值的：如果第一个操作数已经能够确定表达式的值，第二个就不必计算了
- expression1 && expression2
-- 若 expression1 为 false 则结果不可能为 true，expression2 不计算；若 expression1 为 true，expression2计算
- expression1 || expression2
-- 若 expression1 为 true，expression2 不计算；若 expression1 为 false，expression2 计算

- 三元运算符
-- condition ? expression1 : expression2
-- condition 为 true， 取 expression1 的值；否则 取 expression2 的值
-- 例如： x < y ? x : y 返回 x 和 y 中较小的一个


# 位运算符
- 处理整型类型时，可以直接对组成整型数值的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位运算符包括：&、｜、^、~
- 应用在布尔值上，& 和 | 也能得到一个布尔值，只不过不采用短路的方式求值
- 移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型，在这种情况下需要对右操作数模 64）即：1 << 35 的值等同于 1 << 3
- & 位与 两个操作数转为二进制的第 n 位都为 1，则结果的第 n 位为 1
- | 位或 两个操作数转为二进制的第 n 位只要一个为 1，则结果的第 n 位为 1
- ^ 位异或 两个操作数转为二进制的第 n 位不一样，则结果的第 n 位为 1
- ~ 位非 位非是一元操作符 操作数各位（包括符号位）取反<br>
-- ~5 = -6<br>
-- 5 转换为二进制：  0000 0000 0000 0000 0000 0000 0000 0101<br>
-- -6 转换为二进制： 1111 1111 1111 1111 1111 1111 1111 1010<br>
-- 负数以原码的补码形式表达<br>
-- -6 的原码为:     1000 0000 0000 0000 0000 0000 0000 0110<br>
-- -6 原码的补码为： 1111 1111 1111 1111 1111 1111 1111 1010<br>
-- >> 右移 抹去右边的数，用符号位补足高位。整数一直右移，会变成 0，负数如果一直右移，最终会变成 -1，即 (-1) >> 1 是 -1<br>
-- << 左移 右边补 0，一个正数在左移的过程中会有正有负的情况；负数左移不会特殊处理符号位。如果一直左移，最终会变成最小的 int 值<br>
-- >>> 无符号右移，忽略符号位，抹去右边的数，空位都以 0 补齐<br>
- 这些运算符按位模式处理。例如，a & b。先把 a b 转为二进制，再从右往左开始对齐比较，若第 n 位数都为 1， 则得到的结果的 第 n 位为 1，如此比较到最左侧

# 位运算符使用技巧
- 判断奇偶数
-- 利用 & 位运算符，判断正整数二进制（有效数字位，非符号位）第一位是 0 还是 1
-- if((a & 1) == 0) 代替 if(a % 2 == 0) 只要正整数最低位不为 1，则该数便为偶数

- 交换两个数
-- 常规做法
-- 借助临时变量
-- int temp = a; a = b; b = temp;
-- 借助累加和
-- a = a + b; b = a - b; a = a - b;
-- 使用 ^ 位运算符
-- a ^= b; b ^= a; a ^= b;
-- 步骤解析：a = a ^ b; b = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a; a = a ^ b = (a ^ b) ^ b = (a ^ a) ^ b = b;
-- 因为 ^ 的特性
-- a ^ a = 0; a ^ 0 = a; (a ^ b) ^ c = a ^ (b ^ c)

- 取余
-- 取余算法和上面的判断奇偶数原理是一样的, 比如说我们要让 a 对 16 进行取余，那么就可以让 a & 15 得出来的结果就是余数
-- 15 的二进制表示为：0000 0000 0000 0000 0000 0000 0000 1111
-- a & 15 就是a二进制的最低四位, 也就是 a & 15 = a / 16
-- 使用 & 来进行取余的算法比使用 / 效率高很多，虽然只能对 2 ^ n 的数值进行取余计算，但是在 JDK 源码中也是经常被使用到，比如说 HashMap中 判断 key 在 Hash 桶中的位置

- 生成第一个大于 a 的满足 2 ^ n 的数
-- 在 HashMap 中我们需要生成一个 Hash 桶，用来存储键值对（或者说存储链表），当我们查询一个 key 的时候，会计算出这个 key 的 hashCode，然后根据这个 hashCode 来计算出这个 key 在 hash 桶中的落点，由于上面介绍的使用 & 来取余效率比 / 效率高，所以 HashMap 中根据 hashCode 计算落点使用的是 & 来取余，使用 & 取余有一个局限性就是除数必须是 2 ^ n，所以 hash 桶的 size 必须是 2 ^ n。由于 HashMap 的构造器支持传入一个初始的 hash 桶的 size，所以 HashMap 需要对用户传入的 size 进行处理，生成一个第一个大于 size 的并且满足 2 ^ n 的数。
-- 一般方法，循环判断
```
public static final int tableSizeFor(int cap)
{
    int size = 1;
    while (size < cap)
    {
        size *= 2;
    }
    return size;
}
```
-- | 位运算符
```
public static final int tableSizeFor(int cap)
{
    // cap = 3
    // n = 3 - 1 = 2
    int n = cap - 1;
    // n = n | (n >>> 1) = 2 | (2 >>> 1) = 2 | 1 = 3
    n |= n >>> 1;
    // n = n | (n >>> 2) = 3 | (3 >>> 2) = 3 | 0 = 3
    n |= n >>> 2;
    // n = n | (n >>> 4) = 3 | (3 >>> 4) = 3 | 0 = 3
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```
- 求相反数
```
// a = 3
// ~a + 1 的二进制表示为；1111 1111 1111 1111 1111 1111 1111 1101
 ~a + 1
```
- 求绝对值
```a >> 31 == 0 ? a : (~a + 1)```

- 用于消去 a 的最后一位的 1
```
// a = 1100
// a - 1 = 1011
// a & (a - 1) = 1000
a & (a - 1)
```
-- 用 O(1) 时间检测整数 n 是否是 2 的幂次
思路解析：N 如果是 2 的幂次，则 N 满足两个条件。
1.N > 0
2.N 的二进制表示中只有一个 1
一位 N 的二进制表示中只有一个 1，所以使用 N & (N - 1)将唯一的一个1消去。
如果 N 是 2 的幂次，那么 N & (N - 1)得到结果为0，即可判断
-- 计算在一个 32 位的整数的二进制表示中有多少个 1
思路解析：
由 a & (a - 1) 消去 a 最后一位知。循环使用a & (a - 1)消去最后一位 1，计算总共消去了多少次即可
-- 将整数 A 转换为 B，需要改变多少个 bit 位
思路解析
这个应用是上面一个应用的拓展。
思考将整数 A 转换为 B ，如果 A 和 B 在第 i（0 <= i < 32）个位上相等，则不需要改变这个 BIT 位;如果在第 i 位上不相等，则需要改变这个 BIT 位。所以问题转化为了 A 和 B 有多少个 BIT 位不相同。联想到位运算有一个异或操作，相同为 0，相异为 1，所以问题转变成了计算 A | B 之后这个数中 1 的个数。
如 3 | 2, 3 转为 2，改变一位就可以；16 | 4，16 转为 4，改变两位就可以

- 使用二进制进行子集枚举
-- 给定一个含不同整数的集合，返回其所有的子集
如果 S = [1, 2, 3]，有如下的解：
[ [3], [1], [2], [1, 2, 3], [1, 3], [2, 3], [1, 2] ]
思路就是使用一个正整数二进制表示的第 i 位是 1 还是 0，代表集合的第 i 个数取或者不取。所以从 0 到 2n - 1 总共 2n 个整数，正好对应集合的 2 ^ n -  1个子集。
```
int[] s = {1, 2, 3};
for(int i = 0; i < ( 1 << s.length); i ++)
{
    StringBuilder text = new StringBuilder("[");
    for(int j = 0; j < s.length; j ++)
    {
        if((i & 1 << j) == 0)
            text.append(s[j] + ", ");
    }
    if(text.length() > 1)
        System.out.println(text.replace(text.length() - 2, text.length(), "]").toString());
}
```

- 运算符级别
-- 如果不使用圆括号，就按照给出的运算符优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（除了右结合运算符）
--- 运算符优先级, 自上到下优先级别依次降低
```
[] . ()     从左向右
! ~ ++ -- +(一元运算符，比如正符号) -(一元运算符，比如负符号) ()(强制类型转换) new      从右向左
* / %       从左向右
+ -         从左向右
<< >> >>>   从左向右
< <= > >= instanceof        从左向右
== !=       从左向右
&           从左向右
^           从左向右
|           从左向右
&&          从左向右
||          从左向右
?:          从左向右
= += -= *= /= %= &= |= ^= <<= >>= >>>=      从右向左
```

- String
-- String 就是 Unicode 字符序列
-- 需要把多个字符串放在一起，用一个定界符分割，可以使用静态 join 方法
```
// all = "S / M / L / XL"
String all = String.join(" / ", "S", "M", "L", "XL");
```
- 由于不能修改字符串的字符，所以 Java 文档中将 String 类对象成为不可变字符串，虽然不可变字符串效率不高，但编译器可以让字符串共享
- 要检测两个字符串是否相等，而不区分大小写，可以使用 equalsIgnoreCase 方法
```
"Hello".equalsIgnoreCase("hello")
```
- 一定不要使用 == 检测两个字符串是否相等！这个运算符只能够确定两个两个字符串是否放置在同一个位置上，当然，如果字符串放置在同一个位置上，它们必然相等。但是完全有可能将内容相同的多个字符串放在不同的位置上。如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等。但是实际上，只有字符串常量是共享的， 而 + 或 substring 等操作产生的结果并不是共享的。
- 空串 “” 是长度为 0 的字符串，空串是一个 Java 对象，有自己的串长度和内容。不过，String 变量还可以存放一个特殊的值，名为 null，这表示目前没有任何对象与该变量关联
- Java 字符串由 char 值序列组成，char 数据类型是一个采用 utf-16 编码表示 Unicode 码点的代码单元。大多数的常用 Unicode 字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。
- legnth 方法将返回采用 utf-16 编码表示的给定字符串所需要的代码单元数量，想要得到实际的长度，即码点数量，可以调用
```
int cpCount = "hello".codePointCount(0, "hello".length());
```


