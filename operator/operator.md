- 当参与 / 运算的两个操作数都是整数时，表示整数除法，否则表示浮点除法
-- 需要注意的是，整数 / 0 会产生一个异常；浮点 / 0 会得到无穷大或 NaN 结果

- 为了可移植性，Java 虚拟机的最初规范规定所有的中间计算都必须进行截断。这种行为遭到了数值计算团队的反对。截断计算不仅可能导致溢出，而且由于阶段操作需要消耗时间，所以在计算速度山实际要比精确计算慢。为此 Java 程序设计语言承认最优性能与理想结果存在的冲突。在默认情况下虚拟机设计者允许对中间计算结果采用扩展的精度。但是对于 strictfp 关键字标记的方法或类必须使用严格的浮点计算

- 计算数值的平方根 Math.sqrt(x)
- 幂运算 Math.pow(x, a) pow 方法有两个 double 类型的参数，其返回结果也为 double

- floorMode 方法的目的是解决一个长期存在的有关整数取余的问题。如 n % 2，一般 n 是偶数，则表达式为 0；若 n 是奇数，则表达式为 1；若 n 是负数，则表达式为 -1.为什么呢？设计最早的计算机时，必须有人制定规则，明确整数除法和求余对负数操作数该如何处理。根据最优（欧几里得）原则：余数总要大于等于 0，但最早制订规则的人，提出一些看似合理但实际上很不方便的规则。
-- 例如：计算一个时钟时针的位置，这里要做一个时间调整，而且要归一化为一个 0 ～ 11 之间的数。这很简单：（position + adjustment） % 12 。不过，如果这个调整为负会怎么样？你会得到一个负数，所以要引入一个分支，或者使用（（position + adjustment）% 12 + 12）% 12.不管怎样，总之很麻烦，floorMod（position + adjustment， 12）总会得到一个 0 ～ 11 之间的数，不过若第二个参数为负数，也就是除负数，floorMod会得到负数结果

- 在 Math 类中，为了达到最快性能，所有的方法都是用计算机浮点单元中的历程，如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用 StrictMath 类

# 数值类型之间的转换
- byte ---> short ---> int ---> long 无信息丢失
- char ---> int 无信息丢失
- int ---> float 有信息丢失
- int ---> double 无信息丢失
- long ---> float  有信息丢失
- long ---> double 有信息丢失
- float ---> double  无信息丢失

- 当两个操作数进行二元操作时，需统一类型再进行计算
-- 一个是 double，另一个转为 double
-- 否则，一个是 float，另一个转为 float
-- 否则，一个是 long，另一个转为 long
-- 否则，都被转为 int

- 强制类型转换会丢失信息，想对浮点数做舍入运算，得到最接近的整数 Math.round 方法，返回 long 类型
-- 当强制类型转换时，超出目标类型的表示范围，则会被截断一个完全不同的值，如（byte）300 的实际值为 44

- 赋值中使用二元运算符，将运算符写在 = 的左边

- 自增运算符，前缀先加后运算，后缀先运算后加
-- 建议不要使用 自增运算

- && 逻辑与  只有两个表达式结果都为 true，则其结果为 true
- || 逻辑或  只要一个表达式结果为 true，则其结果为 true
- &&  和 || 都是按照短路的方式求值的：如果第一个操作数已经能够确定表达式的值，第二个就不必计算了
- expression1 && expression2
-- 若 expression1 为 false 则结果不可能为 true，expression2 不计算；若 expression1 为 true，expression2计算
- expression1 || expression2
-- 若 expression1 为 true，expression2 不计算；若 expression1 为 false，expression2 计算

- 三元运算符
-- condition ? expression1 : expression2
-- condition 为 true， 取 expression1 的值；否则 取 expression2 的值
-- 例如： x < y ? x : y 返回 x 和 y 中较小的一个


# 位运算符
- 处理整型类型时，可以直接对组成整型数值的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位运算符包括：&、｜、^、~
- & 位与 两个操作数转为二进制的第 n 位都为 1，则结果的第 n 位为 1
- | 位或 两个操作数转为二进制的第 n 位只要一个为 1，则结果的第 n 位为 1
- ^ 位异或 两个操作数转为二进制的第 n 位不一样，则结果的第 n 位为 1
- ~ 位非 位非是一元操作符 操作数各位取反
-- ~5 = -6
-- 5 转换为二进制：  0000 0000 0000 0000 0000 0000 0000 0101
-- -6 转换为二进制： 1111 1111 1111 1111 1111 1111 1111 1010
-- 负数以原码的补码形式表达
-- -6 的原码为:     1000 0000 0000 0000 0000 0000 0000 0110
-- -6 原码的补码为： 1111 1111 1111 1111 1111 1111 1111 1010
- 这些运算符按位模式处理。例如，a & b。先把 a b 转为二进制，再从右往左开始对齐比较，若第 n 位数都为 1， 则得到的结果的 第 n 位为 1，如此比较到最左侧
1000 0000 0000 0000 0000 0000 0000 0110
1111 1111 1111 1111 1111 1111 1111 1001