- int 4字节 32bit 因为 int 取值有正负数，则高一位用来区分正负，故 int 的取值范围为正负2的31次方

- 二进制以补码运算
- 负数以原码的补码形式表达
- 原码：一个 int 实数按照其绝对值大小转换为二进制数，负数最高位补 1， 正数不变
- 由于原码存在 +0 和 -0，而且进行异号相加或同号相减时，先判断 2 个数的绝对值大小，然后进行加减操作，最后运算结果的符号还要与大的操作数的符号相同

- 反码：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反
- 反码是相互的，另外还存在 +0 和 -0

- 补码：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加 1

- 十六进制数值有一个前缀 0x 或 0X
- 八进制有一个前缀 0 （八进制表示法比较容易混淆，故不建议使用八进制常数）

- 从 Java 7 开始，加上前缀 0b 或 0B 就可以写二进制，还可以为数字字面量加下划线，如 1_000_000（或 0b1111_0100_0010_0100_0000）表示一百万，下划线只是为了易读性，Java 编译器会去除这些下划线。

- 在 C/C++ 中， int 和 long 等数据类型的大小与目标平台有关，比如在 8086 这样的 16 位处理器上整型数值占 2 字节；不过在 32 位处理器上，整型数值占 8 字节

- Java 没有任何无符号形式的 整型数据类型

- double 类型精度是 float 的两倍，绝大部分应用程序都采用 double 类型。 float 的精度很难满足需求。float 类型的数值都有一个后缀 F 或 f。没有后缀 F 的浮点数，默认为 double。
- 可以用十六进制表示浮点数值，例如 0.125 = 2 的负三次方 表示为 0x1.0p-3（格式为：尾数[十六进制]｜ 指数[十进制]），结果为十进制，尾数采用十六进制，指数采用十进制，指数的基数 p 是 2
-- 0x1.0p-3 = 0.125
-- 0x1p-3 = 0.125
-- 0x2p-3 = 0.25
-- 0x4p-3 = 0.5
-- 0x8p-3 = 1.0
-- 0xap-3 = 1.25
-- 0x10p-3 = 2.0（16 * 2 的负三次方）
-- 0x1p-4 = 0.0625

- 浮点数转为二进制：整数部分：除 2 取余，逆序排列；小数部分：乘 2 取整，顺序排列
- 小数部分可能造成死循环计算，就好像十进制的‘三分之一’一样，浮点数 0.9 转为二进制的精度就无法确认。

# float 精度误差
- flaot 内存存储结构
-- 4 bytes     31              30              29-23           22-0
-- 表示为       实数符号位       指数符号位       指数位           有效数位
- flaot ---> 内存存储步骤
-- 1、其绝对值转为二进制
-- 2、若实数小于 1 则右移 n 位，否则左移 n 位，直到小数点移动到第一个有效数字的右边
-- 3、从小数点右边第一位开始数 23 位 放入 float 32 位的第 22 位到第 0 位
-- 4、如果原数为正，则第 31 实数符号位为 0， 否则为 1
-- 5、如果 n 是左移的，说明指数是正的，第 30 指数符号位 为 1；n 是 右移或者n = 0， 第 30 指数符号位 为 0
-- 6、左移：n - 1 的值转为二进制，然后补齐 7 位，放入 flaot 第 29 - 23 位
   n = 0: n 的值转为二进制，补足 7 位，取反，放入 flaot 第 29 - 23 位
   右移：n 的值转为二进制，补足 7 位，取反，放入 flaot 第 29 - 23 位

- 11.9
-- 1、将 11.9 转为二进制大概是“1011.1110011001100110011001100...”
-- 2、将小数点左移三位到第一个有效位右侧“1.01111100110011001100110...”
-- 3、从小数点右边第一位开始数 23 位（误差这里产生了），得到“011 111 001 100 110 011 001 10”共 23 位，放入 float 存储结构的第 22 位到第 0 位
-- 4、因为 11.9 是正数，则第 31 位实数符号 为 0
-- 5、由于我们把小数点左移，则指数为正，因此在第 30 位指数符号位放入 1
-- 6、因为我们是把小数点左移 3 位，因此 3 - 1 = 2，化为二进制，补足 7 位 得到“0000010”， 放入第 29 位到第 23 位

- 则 11.9 ---> 0 1 0000010 01111100110011001100110

- 内存存储的 float 二进制转为十进制步骤：
-- 1、将第 22 位到第 0 位写出来，在最左边补 1， 得到二十四位有效数字，将小数点点在最左侧 1 的右边
-- 2、取出第 29 到第 23 位所表示的值 n。当 30 位是“0”时将 n 各位求反。当 30 位是“1”时将 n 增1
-- 3、将小数点左移 n 位（当 30 位是“0”时）或右移 n 位（当 30 位是“1”时），得到一个二进制表示的实数
-- 4、将这个二进制实数化为十进制，并根据第 31 位是“0”还是“1”加上正号或负号即可

- 所有的浮点数值计算都遵循 IEEE754 规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：正无穷大、负无穷大、NaN（不是一个数字）
不能直接使用 x == Double.NaN。所有的“非数值”都是不相同的，但是可以使用 Double.NaN(x) 方法


- 浮点数不能用于要求精度计算的领域，如若要求计算精度可使用 BigDecimal

- char 原本用于表示单个字符，如今有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符需要用到两个 char 值
- char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff

- Unicode 转义字序列会在解析代码之前得到处理，故要小心注释中的 \u
- 建议不要再程序中使用 char 类型

- 尽管 $ 是一个合法的 Java 字符，但建议不要在自己的程序中使用，它只用于 Java 编译器或其他工具生成的名字中，不提倡在一行申请多个变量
- 在 Java 中，变量的声明尽可能地靠近变量第一次使用的地方
